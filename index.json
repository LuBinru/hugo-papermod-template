[{"content":"MyBatisPlus分页不生效后的探索 今天我在使用MyBatisPlus的IPage接口进行分页查询时，遇到了一个问题：分页并没有生效，结果直接返回了整个数据集。我查阅了官方文档，但没有找到我这几行代码的问题所在。于是我开始搜索关于\u0026quot;MyBatisPlus分页不生效\u0026quot;的原因和解决办法，但大多数结果都在讨论\u0026quot;未配置分页拦截器\u0026quot;这个问题。\n经过测试，我发现分页拦截器根本没有启动。\n在浏览了几页的搜索结果后，我没有找到解决方案。\n实际上，问题出在META-INF目录的位置上。META-INF目录需要放置在resources根目录下，否则无法被正确扫描到。META-INF没有被扫描，在这之前没碰到过的一个小问题。\nMETA-INF目录用于存放元数据信息，例如包和扩展的配置数据。\n与分页拦截器是否启动直接相关的是spring.factories文件。\nspring.factories的作用是自动加载Spring扩展的实现类。它需要以properties格式（键值对）进行配置。这个机制提供了一种将外部包中的类注入到Spring容器中的方式。换句话说，如果Spring要加载根目录以外的Bean，例如Maven依赖中的Bean，就需要使用spring.factories。\n这是一种解耦的扩展机制。\n基本原理是在spring-core包中的SpringFactoriesLoader类中，它实现了对META-INF/spring.factories文件的检索，并根据配置信息实例化这些功能类，最后将它们注册到Spring容器中。\n相关代码如下：\npublic final class SpringFactoriesLoader { //文件路径  public static final String FACTORIES_RESOURCE_LOCATION = \u0026#34;META-INF/spring.factories\u0026#34;; ... /** * 根据给定的类型返回一个包含这些实现类对象的列表 */ public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; loadFactories(Class\u0026lt;T\u0026gt; factoryType, @Nullable ClassLoader classLoader) { Assert.notNull(factoryType, \u0026#34;\u0026#39;factoryType\u0026#39; must not be null\u0026#34;); ClassLoader classLoaderToUse = classLoader; if (classLoader == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } List\u0026lt;String\u0026gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse); if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Loaded [\u0026#34; + factoryType.getName() + \u0026#34;] names: \u0026#34; + factoryImplementationNames); } List\u0026lt;T\u0026gt; result = new ArrayList(factoryImplementationNames.size()); Iterator var5 = factoryImplementationNames.iterator(); while(var5.hasNext()) { String factoryImplementationName = (String)var5.next(); result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse)); } AnnotationAwareOrderComparator.sort(result); return result; } /** * 根据给定的类型加载类路径的全限定名 */ public static List\u0026lt;String\u0026gt; loadFactoryNames(Class\u0026lt;?\u0026gt; factoryType, @Nullable ClassLoader classLoader) { ClassLoader classLoaderToUse = classLoader; if (classLoader == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } String factoryTypeName = factoryType.getName(); return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList()); } /** * 根据类加载器，加载Factory实现类，返回一个包含这些实现类的Map对象 */ private static Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; loadSpringFactories(ClassLoader classLoader) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = (Map)cache.get(classLoader); if (result != null) { return result; } else { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = new HashMap(); try { Enumeration\u0026lt;URL\u0026gt; urls = classLoader.getResources(\u0026#34;META-INF/spring.factories\u0026#34;); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Map.Entry\u0026lt;?, ?\u0026gt; entry = (Map.Entry)var6.next(); String factoryTypeName = ((String)entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); String[] var10 = factoryImplementationNames; int var11 = factoryImplementationNames.length; for(int var12 = 0; var12 \u0026lt; var11; ++var12) { String factoryImplementationName = var10[var12]; ((List)result.computeIfAbsent(factoryTypeName, (key) -\u0026gt; { return new ArrayList(); })).add(factoryImplementationName.trim()); } } } result.replaceAll((factoryType, implementations) -\u0026gt; { return (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); }); cache.put(classLoader, result); return result; } catch (IOException var14) { throw new IllegalArgumentException(\u0026#34;Unable to load factories from location [META-INF/spring.factories]\u0026#34;, var14); } } } ","permalink":"https://LuBinru.github.io/hugo-papermod-template/posts/mybatisplus%E5%88%86%E9%A1%B5%E4%B8%8D%E7%94%9F%E6%95%88%E5%90%8E%E7%9A%84%E6%8E%A2%E7%B4%A2/","summary":"MyBatisPlus分页不生效后的探索 今天我在使用MyBatisPlus的IPage接口进行分页查询时，遇到了一个问题：分页并没有生效，结果直接返回了整个数据集。我查阅了官方文档，但没有找到我这几行代码的问题所在。于是我开始搜索关于\u0026quot;MyBatisPlus分页不生效\u0026quot;的原因和解决办法，但大多数结果都在讨论\u0026quot;未配置分页拦截器\u0026quot;这个问题。\n经过测试，我发现分页拦截器根本没有启动。\n在浏览了几页的搜索结果后，我没有找到解决方案。\n实际上，问题出在META-INF目录的位置上。META-INF目录需要放置在resources根目录下，否则无法被正确扫描到。META-INF没有被扫描，在这之前没碰到过的一个小问题。\nMETA-INF目录用于存放元数据信息，例如包和扩展的配置数据。\n与分页拦截器是否启动直接相关的是spring.factories文件。\nspring.factories的作用是自动加载Spring扩展的实现类。它需要以properties格式（键值对）进行配置。这个机制提供了一种将外部包中的类注入到Spring容器中的方式。换句话说，如果Spring要加载根目录以外的Bean，例如Maven依赖中的Bean，就需要使用spring.factories。\n这是一种解耦的扩展机制。\n基本原理是在spring-core包中的SpringFactoriesLoader类中，它实现了对META-INF/spring.factories文件的检索，并根据配置信息实例化这些功能类，最后将它们注册到Spring容器中。\n相关代码如下：\npublic final class SpringFactoriesLoader { //文件路径  public static final String FACTORIES_RESOURCE_LOCATION = \u0026#34;META-INF/spring.factories\u0026#34;; ... /** * 根据给定的类型返回一个包含这些实现类对象的列表 */ public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; loadFactories(Class\u0026lt;T\u0026gt; factoryType, @Nullable ClassLoader classLoader) { Assert.notNull(factoryType, \u0026#34;\u0026#39;factoryType\u0026#39; must not be null\u0026#34;); ClassLoader classLoaderToUse = classLoader; if (classLoader == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } List\u0026lt;String\u0026gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse); if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Loaded [\u0026#34; + factoryType.","title":"MyBatisPlus分页不生效后的探索"},{"content":"Markdown 标题 共有6级标题\nH1 H2 H3 H4 H5 H6 段落 这是第一段，bulabulabula\n这是第二段，bulabulabula\n引用 这是行内引用inline\n 这是一个段引用和脚标的栗子\n— 出处1\n 表格    Name Age     Bob 27   Alice 23    代码块 import os print(\u0026#34;hello world\u0026#34;) 列表 有序列表  First item Second item Third item  无序列表  List item Another item And another item  KaTeX    Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\) Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEmoji 可以直接输入Emoji表情，或者使用shortcode\n🙈 🙈 🙉 🙉 🙊 🙊\n夜间模式 RSS link\n  这是一个脚标的栗子\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://LuBinru.github.io/hugo-papermod-template/posts/hello-world/","summary":"Markdown 标题 共有6级标题\nH1 H2 H3 H4 H5 H6 段落 这是第一段，bulabulabula\n这是第二段，bulabulabula\n引用 这是行内引用inline\n 这是一个段引用和脚标的栗子\n— 出处1\n 表格    Name Age     Bob 27   Alice 23    代码块 import os print(\u0026#34;hello world\u0026#34;) 列表 有序列表  First item Second item Third item  无序列表  List item Another item And another item  KaTeX    Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.","title":"Hello World"}]